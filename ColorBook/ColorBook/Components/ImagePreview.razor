@inject IJSRuntime JS

<section class="image-preview__wrapper">

    <div>
        <img class="image-preview__image" id="@_imageId" src="@imageDataUrl"
             @onmousemove="OnMouseMove" @onmousedown="OnMouseDown" @onmouseover="OnMouseOver" @onmouseout="OnMouseOut" @onmousemove:stopPropagation="true" />
        <canvas class="@cssDetails" id="@_previewCanvasId"></canvas>
    </div>

    <div class="image-preview__options">

        <button class="@cssTracking" @onclick="ChangeTracking" title="tracking color under cursor">
            <img src="/assets/track-icon.svg" />
        </button>

        <button class="@cssTrackingLocked" @onclick="ChangeTrackingLocked" title="constant tracking color under cursor">
            <img src="/assets/track-lock-icon.svg" />
        </button>

    </div>

</section>

@code {
    [Parameter]
    public string ColorHex { get; set; }
    [Parameter]
    public EventCallback<string> ColorHexChanged { get; set; }

    IBrowserFile file;
    [Parameter]
    public IBrowserFile File
    {
        get => file;
        set => SetFile(value);
    }

    readonly int _previewScale = 4;
    readonly string _imageId = "imageId";
    readonly string _previewCanvasId = "previewId";

    string imageDataUrl;

    bool isImageLoaded => imageDataUrl != null;

    bool isMouseOver = false;

    string cssDetails => isImageLoaded && isMouseOver ? "image-preview__details-view" : "image-preview__details-view image-preview__details-view--hidden";

    bool isTracking = false;
    bool isTrackingLocked = false;
    string cssTracking => isTracking ? "image-preview__option image-preview__option--first image-preview__option--active" : "image-preview__option image-preview__option--first";
    string cssTrackingLocked => isTrackingLocked ? "image-preview__option image-preview__option--last image-preview__option--active" : "image-preview__option image-preview__option--last";


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await JS.InvokeVoidAsync("colorPreview.initPreview", _previewCanvasId, _previewScale);
    }

    void OnMouseOver(MouseEventArgs e) => isMouseOver = true;

    void OnMouseOut(MouseEventArgs e) => isMouseOver = false;

    async Task OnMouseDown(MouseEventArgs e)
    {
        await SetColor();
        if (isTracking)
            isTracking = false;
    }

    async Task OnMouseMove(MouseEventArgs e)
    {
        if (!isImageLoaded)
            return;

        await JS.InvokeVoidAsync("colorPreview.setPreview", _imageId, _previewCanvasId, e.OffsetX, e.OffsetY, _previewScale);

        if (isTracking || isTrackingLocked)
            await SetColor();
    }

    async Task SetColor()
    {
        var rgba = await JS.InvokeAsync<int[]>("colorPreview.getRGBA", _previewCanvasId);
        var hex = await JS.InvokeAsync<string>("colorPreview.rgbToHex", rgba[0], rgba[1], rgba[2]);

        ColorHex = hex;
        await ColorHexChanged.InvokeAsync(ColorHex);
    }

    void SetFile(IBrowserFile value)
    {
        if (file == value)
            return;
        file = value;
        InvokeAsync(SetImageData);
    }

    async Task SetImageData()
    {
        if (file == null)
        {
            imageDataUrl = null;
            return;
        }

        var width = await JS.InvokeAsync<int>("colorPreview.getWindowWidth");
        var height = await JS.InvokeAsync<int>("colorPreview.getWindowHeight");

        var maxWidth = width < 500 ? width : 500;
        var maxHeight = height < 700 ? height : 700; ;

        var format = "image/png";
        var resized = await file.RequestImageFileAsync(format, maxWidth, maxHeight);
        var buffer = new byte[resized.Size];
        await resized.OpenReadStream().ReadAsync(buffer);
        imageDataUrl = $"data:{format};base64,{Convert.ToBase64String(buffer)}";

        StateHasChanged();
    }

    void ChangeTracking()
    {
        isTracking = !isTracking;
        if (isTracking)
            isTrackingLocked = false;
    }

    void ChangeTrackingLocked()
    {
        isTrackingLocked = !isTrackingLocked;
        if (isTrackingLocked)
            isTracking = false;
    }

}
